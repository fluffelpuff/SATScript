<pre>
  Title: SATScript Universe / Contract VM (PreWhitePaper)
  Author: 
    Fluffel₿uff
      Twitter: https://twitter.com/fluffelpuffcode
      Nostr: npub14hewvxry7lp6wzec0rzcc6py9qr46seeagkx0c7mkmr3rckex3dq88hzee
  Comments-Summary: Noch in bearbeitung
  Status: Entwurf
</pre>

== Einführung ==

=== Abstrakt ===

Dieses Dokument beschreibt, welche Funktionen die Universen und virtuellen Maschinen in SATScript haben,
es beschreibt, wie Daten geschrieben und gelesen werden und wie eine Absicherung der Daten über mehrere Nodes hinweg erreicht wird.

=== Motivation ===

Es ist ein Versuch zu beweisen, dass Smart Contracts auch auf Bitcoin umsetzbar sind und dass mit einer hoher Funktionalität.
Smart Contracts, die im Hauptlayer ausgeführt/ausgewertet werden, haben aus meiner Sicht nachfolgende Nachteile:
* Durch massenhafte On-Chain Ausführung/Auswertung von Smart Contracts wird der Mempool belastet. Dies führt wiederum zu höheren Gebühren und längeren Wartezeiten bei Transaktionen.
* Die Zensurresistenz einer Blockchain wird verringert, insbesondere die des Vertrags. Die Adresse eines Vertrags kann unter bestimmten Umständen auf eine schwarze Liste gesetzt werden. Dies hätte zur Folge, dass eine Interaktion mit diesem Vertrag nur schwer oder gar nicht mehr möglich wäre.
* Alle Vertragsinteraktionen sind für immer in der Blockchain gespeichert. Das schwächt die Anonymität einzelner Vertragsparteien. Auch wenn die Transparenz einer Blockchain im Hauptlayer unumgänglich für ihre Sicherheit ist, kann es für einzelne Nutzer Probleme geben, wenn jeder ihre Vertragsinteraktionen nachvollziehen kann.
* Es müssen X-mal mehr Daten auf der Blockchain gespeichert werden, was zu einer Zentralisierung führen kann. Auch wenn das Speichern immer günstiger wird, sind Terabytes auf Handys und Co. noch kein Standard. Selbst dann stellt sich die Frage: "Muss alles für immer On-Chain gespeichert werden?"
* Nachdem ein Vertrag auf der Blockchain initialisiert wurde, kann dieser nicht mehr verändert werden. Auf der einen Seite ist das eine Kerneigenschaft einer Blockchain und unumgänglich für den Betrieb einer Blockchain. Der Code des Vertrags ist für immer in der Blockchain gespeichert. Auch dann, wenn der Vertrag von niemandem mehr verwendet wird, bleibt er für immer online. Bei Ethereum erhält ein Vertrag oft einen Eigentümer, der in der Lage ist, den "dezentralen" Smart Contract zu stoppen. Dies hat bei einem fehlerhaften Vertrag zwar den Vorteil, dass neue Nutzer geschützt werden können, da eine Interaktion mit dem Vertrag nicht mehr möglich ist. Es stellt jedoch die Dezentralität des Smart Contracts in Frage, wenn zentrale Stellen in der Lage sind, einen "dezentralen" Vertrag aufzuhalten. Deshalb stellt sich die Frage: "Ist es unbedingt notwendig, einen Smart Contract auf einer Blockchain zu speichern?"


Die Ausführung eines Smart Contracts ist mit der Ausführung eines normalen Programms oder einer App vergleichbar, mit dem Unterschied, dass jede Operation durch kryptographische (und andere) Funktionen so zusammengefasst wird, dass jeder auf der Blockchain prüfen kann, ob der Contract korrekt ausgeführt wurde und die Ausgabe der Funktion korrekt ist. Diese Eigenschaft nennt man auch Determinismus, bei gleicher Eingabe muss die gleiche Ausgabe herauskommen. Lightning hat demonstriert, dass Transaktionen auch im Second Layer übertragen werden können. Nun stellt sich die Frage, ob es mit dem Lightning-Konzept möglich ist, Smart Contracts zwischen zwei oder eventuell auch mehreren Teilnehmern auszuführen, ohne dass der Contract auf einer Blockchain initialisiert werden muss.

=== Rollen ===

Innerhalb eines Containers können Teilnehmer die folgenden Rollen (Rechte) haben:

**Master Node:**
* Verwaltet einen privaten Schlüssel für die Container MuSig Wallet.
* Verwaltet die Container-Account-Wallet (enthält die Beträge einzelner Account-Adressen).
* Verwaltet den Data Storage, der die Variablen eines Contracts speichert.

**Slave / Client Node:**
* Kann alle aktuellen Zustände eines Containers oder Contracts auslesen.
* Kann containerbasierte Account-Transaktionen durchführen.
* Ein Slave verfügt nicht über das Recht, selbst Änderungen in der Container-Account-Wallet oder im Data Storage durchzuführen (nur lesen).
* Weitere Informationen zu den Unterschieden zwischen Slave- und Master-Nodes werden im Dokument genauer erläutert.

=== Beschreibung ===

Die Aufgabe eines SATScript-Containers besteht darin, die Mainlayer-MuSig-Wallet zu verwalten, die Kontostände der Adressen innerhalb des Containers zu führen und den Data Storage zu verwalten, der die Contract-Daten speichert. Diese Daten bilden den gesamten Zustand eines Containers ab und müssen von allen Container-Master-Nodes synchronisiert werden. Innerhalb eines Containers ist es möglich, ähnlich wie auf Lightning oder der Mainchain, Transaktionen zwischen zwei Adressen durchzuführen. Dabei müssen weder der Absender noch der Empfänger eine Master-Rolle innerhalb des Containers einnehmen. Sofern ein Container nichts anderes konfiguriert hat, kann jeder Satoshis in einen Container einzahlen (PegIn), auszahlen (PegOut) und innerhalb des Containers Transaktionen durchführen.


Beispiel:
Alice möchte 1.000.000 Satoshis in einen Container mit Bob einzahlen (PegIn). Dazu erstellt sie eine container-spezifische Bitcoin-Einzahlungsadresse, die auf ihre container-spezifische Account-Adresse verweist, und überweist die 1 Million Satoshis auf die erstellte Bitcoin-Adresse. Sobald der Container die Einzahlung erkannt hat, also nach mindestens 6 Bestätigungen, wird der eingezahlte Betrag der Account-Adresse gutgeschrieben und Alice kann die Satoshis nun innerhalb des Containers verwenden.
